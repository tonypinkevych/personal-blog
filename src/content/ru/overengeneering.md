---
title: 'Оверинжиниринг - невидимый враг компании'
description: 'Код нужно писать хорошо, но важно прислушиваться к команде, уважать коллег и ставить цели бизнеса выше личных при работе над продуктом'
pubDate: 'Dec 19 2022'
published: true
---

# Оверинжиниринг - невидимый враг компании

## Предисловие

Технические специалисты ссорятся почти в каждом паблике. Бекендщики и дизайнеры не любят фронтендщиков. Тестировщики жалуются на фронтендщиков и бэкэндщиков. А сами фронтендщики имеют претензии к тестировщикам и дизайнерам. Продолжать можно долго, это превращается в порочный круг. Мне кажется, эти конфликты происходят по следующим причинам:

- продуктовые менеджеры стремятся получить работающую функцию в максимально сжатые сроки;
- тестировщики пытаются тщательно проверить ее и убедиться, что программа будет работать во всех возможных и невозможных ситуациях;
- бэкэндщикам хочется разработать архитектуру, которая сможет выдерживать миллиардные нагрузки и быть максимально расширяемой и защищенной;
- дизайнерам нужно сделать новые UX паттерны, провести user research, чтобы выложить мега case study на Behance;
- фронтендщики объединяют то, что создали дизайнеры и бэкэндщики, во что-то, что работает для конечного пользователя, добавляют от себя анимацию и другие «вкусности».

Каждый пытается сделать свою работу максимально качественно, но иногда не думает о конечной цели. Это приводит к лишним осложнениям на каждом этапе разработки. Но больше всего страдает бизнес. Так с чего начать? Начну с истории.

## Как создать шедевр, который никому не нужен

Жил-был программист. Назовем его Антон. Он работал в крупной продуктовой компании и отвечал за разработку одного из направлений. Его постоянно подгоняли менеджеры и маркетологи, спрашивая, где новые функции, и почему разработка длится так долго. Антону это не нравилось, ведь он - программист и хочет писать качественный софт. Со временем он осознал, что ему хватает опыта, так почему бы не запустить собственную компанию? В ней он будет боссом и сможет сам решать, какой продукт и как делать. А если осуществится все задуманное, компания станет самой успешной в мире. Поэтому Антон накопил стартовый капитал, уволился, отгородился от всего мира и приступил к работе. В течение первого месяца он разрабатывал правильную архитектуру, чтобы пользователи получали контент максимально быстро, а расширять систему было легко. Второй месяц ушел на разработку идеального дизайна и анимации, которые принесут пользователям бесконечную радость от использования приложения. В течение третьего месяца он настраивал удобную систему CI/CD - делаешь один коммит, и все 10 000 нужных сервисов собираются автоматически. В последующие месяцы писался максимально правильный код: покрытие тестами на 100%, все модули системы общаются между собой через интерфейсы, каждый модуль имеет свою ответственность, все зависимости внедряются через DI контейнер и т.д. Через год плодотворной ежедневной работы продукт был готов. Получился шедевр программного обеспечения: простой, быстрый, удобный. Пришло время публичного запуска. Антон написал большой пост в социальные сети, описал продукт, свое видение и процесс. Пост получил сотни лайков от друзей и знакомых, все его похвалили. Но проходит неделя, а у него только две покупки: от самого Антона во время тестирования системы и от случайного пользователя, который впоследствии попросил вернуть деньги. Люди не пользовались продуктом и тем более не платили за него. Время шло, ситуация никак не менялась. Накопленные деньги заканчивались. Антон не понимал, где он промахнулся. «Маркетинг! Конечно же!» - подумалось ему. Он взял денег в долг и запустил рекламную кампанию. Она была дорогой, потому что раньше Антон такого не делал. После этого начали появляться первые пользователи. Они регистрировались, использовали продукт несколько дней, а потом уходили и никогда не возвращались. Деньги закончились, и Антон был вынужден отложить продукт и вернуться в компанию, для которой прибыль была первоочередной.

## Ошибочный подход

Проблема Антона не в маркетинге, а в подходе к разработке программного обеспечения. Люди готовы использовать продукты с плохими интерфейсами, временно терпеть баги и неудобства. **Главное - чтобы продукт решал их проблему.** Ниже скриншот из софта, которым пользуются сотни тысяч стоматологов. Компания успешна? Да. Решает ли продукт проблему? Да. Является ли этот продукт идеальным? Не уверен, судя по дизайну. ![](/ru/overengineering/image_78376713161671190676257.png)_На фото изображен Denticon_ В истории про Антона я специально опустил то, что именно он разработал. В ментальности большинства программистов это не имеет значения. Им важно писать «качественный софт», которым возможно даже никто и не будет пользоваться. Поэтому они могут усложнить систему ради того, чтобы она была абсолютно правильно спроектирована и реализована. Но эта «правильность» часто ошибочна. По моему мнению, технический стек не влияет на успешность продукта. Есть такой парень [levelsio](https://twitter.com/levelsio), который сам себе программист-бизнесмен. Его суммарный доход в год составляет около $4 млн, в том числе прибыль - $3,6 млн. Он пишет на php+html+чистый js, иногда исправляет код прямо на сервере и пишет обо всем этом в Twitter. Недавно он запустил новый бизнес, который назвал [avatarai.me](http://avatarai.me). Такой проект реализовать просто, если не заниматься оверинжинирингом (уже есть несколько клонов). На скриншотах ниже видно, как его продукт выглядит на момент написания статьи. Как видим, даже форма добавления файлов не стилизованная. Идея стартапа в том, чтобы через посадочную страницу получать от пользователей несколько фотографий и вручную «скармливать» их в интерфейс нейросети. Когда сеть была обучена, разработчик генерировал фотографии и «руками» отправлял [](http://onlinecorrector.com.ua/%D1%97%D1%85-%D1%96-%D1%97%D1%85%D0%BD%D1%96%D0%B9) на почты людям, которые заплатили. Когда гипотеза подтвердилась, он автоматизировал этот процесс. Сейчас стартап растет очень быстро: [сервис уже заработал $100К за 10 дней](https://twitter.com/levelsio/status/1589737798244118528?s=20&t=Ex7S2zoNliqp9nfyBmLkbg), а весь Twitter забит аватарками, сделанными с его помощью. ![](/ru/overengineering/image_46078967371671190676477.png) ![](/ru/overengineering/image_53358489781671190676792.png) Понятно, что этот парень - исключение. Но я хочу донести мысль: не нужно пытаться выполнять свою работу идеально в рамках вашего понимания. Ее нужно делать так, чтобы она **идеально решала проблемы конечного потребителя**. Вся команда, вся архитектура и сервисы должны быть нацелены именно на это. Есть готовое SaaS-решение вашей проблемы? Хорошо, используйте его. Базу данных можно пока не поднимать, а использовать redis, или вообще хранить в одном объекте на сервере? Супер, вперед. Отправку уведомлений пользователям можно делать вручную раз в неделю? Прекрасно, можно опустить интеграцию сервиса уведомлений. Главное, чтобы от этого не страдал клиент. Конечно, важно не утонуть в техническом долге, вовремя все интегрировать и автоматизировать. Здесь играет большую роль опыт продуктового менеджера и технического лида.

## Дополнительная ценность

Чтобы определить, что на самом деле важно, нужно понимать, как устроен бизнес и какую ценность создает продукт для пользователя. Если представить, что весь бизнес - это иерархия департаментов, которые связаны между собой, то получим следующее: ![](/ru/overengineering/image_6994059131671190675407.jpg) Самая важная связь - клиент-продукт. Именно здесь создается самая большая ценность, за которую компания получает деньги. Пользователи довольны - компания прибыльна. Пользователи недовольны - они уходят, а компания становится убыточной. Как видите, продукт в этом случае является самым важным. И это необязательно должно быть что-то из IT (сайт, приложение и т.д.). Например, [в нашем случае](https://wisey.app) продукт - это контент. Имеет ли принципиальное значение то, как мы будем его доставлять пользователю? Не совсем. Если в целом посмотреть на требования к продукту, их можно упростить до одного предложения[:](http://onlinecorrector.com.ua/%D0%BF%D1%80%D0%BE%D0%BF%D0%BE%D0%BD%D1%83%D0%B2%D0%B0%D0%BD%D0%BD%D1%8F-%D1%80%D0%B5%D1%87%D0%B5%D0%BD%D0%BD%D1%8F) **дать пользователю возможность заплатить и получить учебный контент**. Представим ситуацию, что у нас вообще нет IT-департамента. В худшем случае можно получать от пользователей переводы с помощью банковских платежей и отправлять им ссылки на курсы по электронной почте. Если взять несколько лучший пример, можно получать оплаты через систему stripe и давать клиентам инвайт в notion. Вариант еще лучше - использовать систему teachable и т.д. Создание собственной системы с нуля - не принципиально, но обязательно, если вы собираетесь получить конкурентное преимущество в виде лучшего UX. Например, продукт компании Netfilx - это контент. Еще в 90-х они давали DVD-диски с фильмами напрокат. То есть для них стриминговая платформа - это лишь процесс доставки их основного продукта. Инфраструктура важна, но она будет меняться со временем. Сегодня мы видим гонку стриминговых сервисов, которые делают акцент на кинопродукции. За неполный 2022 год Netflix уже потратили $18 млрд на создание собственного контента. Пользователи платят за доступ к сериалам и фильмам, а не за гениальный сайт. Если бы на Netflix не было регулярных обновлений контента, никто бы не подписывался, и не было бы дохода. Скорее всего программистов уволили бы, и они ушли домой (привет ребятам из Twitter). **В любой нише существует определенный порог качества. Если ваш продукт ниже этого порога - вы неконкурентны. Если выше, то пользователям уже не так важно, насколько «высоко».**

## Культ software

Программное обеспечение лишь помогает бизнесу вести свою деятельность. **Хватит делать из создания софта и своей работы культ.** Что происходит, когда hardware-инженеры занимаются оверинжинирингом? Виходять [машини Голдберга](https://uk.wikipedia.org/wiki/%D0%9C%D0%B0%D1%88%D0%B8%D0%BD%D0%B0_%D0%A0%D1%83%D0%B1%D0%B0_%D0%93%D0%BE%D0%BB%D0%B4%D0%B1%D0%B5%D1%80%D0%B3%D0%B0). ![](/ru/overengineering/giphy_1.gif) Самое интересное, что программисты пытаются решить несуществующие проблемы не только пользователей, а свои собственные также. Никто не хочет выходить из «пузыря» и сталкиваться с реальным миром, где нужно углубляться в сложную тему, делать ошибки, исправлять их, и все это по кругу. Гораздо проще придумать проблему и решить ее, чем заниматься насущными вопросами. Часто решением реальных задач является прорывная технология. Как, например, в свое время стал React. Но для этого нужно быть смелым, умным, настойчивым и, вообще, визионером. Сейчас же мы имеем кучу аналогов, которые решают уже несуществующую проблему. ![](/ru/overengineering/image_88242004951671190676172.png) Выглядит забавно, но это наша текущая реальность в софтверной разработке, где новые фреймворки и языки программирования выпускаются чуть ли не ежемесячно, часто без обратной совместимости со старыми технологиями. Программисты пытаются успевать за трендами, но получается, что они просто усложняют собственные системы. Иногда разработка новых фреймворков на основе React может быть выгодна, но если вы решаете другую задачу. Так недавно был выкуплен [новый фреймворк Remix компанией Shopify](https://shopify.engineering/remix-joins-shopify). Или посмотрите на успех компании Vercel (создателей NextJS). Я не против прогресса и не против новых фреймворков. Это двигает нас вперед. Эдисон создал тысячу лампочек до того, как получил рабочий вариант. Но пока Эдисон экспериментировал, никто не менял все лампочки в городе с каждым новым прототипом. А еще он пытался получить более доступный свет, а не просто закручивал провод в стекло ногами. Круто, сложно, но не горит. Я предлагаю вернуться к основам, понять, в чем заключается наша задача и уже от этого отталкиваться при решении проблем и поставленных задач.

## Основная задача софта - автоматизация бизнеса

Задача считается выполненной, когда софт автоматизировал бизнес-процесс и сэкономил компании деньги. Разрабатывать, тестировать и поддерживать ПО достаточно сложно и дорого. Поэтому и появились различные архитектуры и методики ведения проектов, призванные удешевить этот процесс. То есть не для того, чтобы программисты учились новому, не для того, чтобы делать софт ради софта, а для того, чтобы **бизнес постоянно уменьшал свои расходы при расширении**. Ниже опишу свои скромные наблюдения, которые могут помочь на старте новых проектов. Весь софт, как и бизнес, можно разделить на разные домены (модули). При этом нужно учитывать основной продукт компании: как он создается, где хранится, где собирается, как распространяется и кому предназначен. Самый важный модуль - тот, который приносит деньги вашей компании, является уникальным, создает ценность и конкурентное преимущество. Остальные модули нужно делать максимально дешево и быстро. Эта идея очень хорошо раскрывается в книге [Domain Driven Design](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215) (DDD), написанной Эриком Эвансом. Как можно достичь гибкости, стабильности и при этом не слишком усложнить? С помощью интерфейсов и разумного разделения ответственности.

1.  Разбиваете всю систему на модули, которые будут использовать только интерфейсы для связи между собой. Если мы заменили один из модулей - система продолжает работать при условии, что новый модуль реализует интерфейс.
2.  Создавайте быстрое решение, которое отвечает минимальным требованиям пользователей. Можно использовать внешние сервисы, писать процедурный или спагетти-код, или как будет быстрее и удобнее команде.
3.  Ввиду того, что модуль будет изолирован интерфейсом, его «начинку» можно будет переписывать бесконечное количество раз. Здесь важно следить за тем, чтобы в вашей системе не было «протекших» абстракций, то есть реализации из разных модулей не ссылались непосредственно друг на друга.
4.  Самое сложное - чтобы каждый модуль был небольшого размера. Основной критерий - возможность написания модуля с нуля в течение одной-двух недель. Если это начинающийся стартап / проект, то количество времени можно уменьшить до трех дней.
5.  Но с интерфейсами внутри модулей не стоит перебарщивать. Каждый из них создает новый слой абстракции. И в какой-то момент уровень абстракций находится слишком далеко от проблемы. И чтобы понять, что делает модуль, нужно просмотреть весь путь данных. В таком большом количестве строк кода также увеличивается количество возможных багов, что влияет на время тестирования. А еще человек может помнить ограниченное количество сущностей. И если уровней очень много, то продуктивно программировать могут только гении. Каждый сам находит свою золотую середину. Для меня работает правило: не более пяти уровней абстракций.
6.  Придерживаться этих пунктов можно и на фронтенде, и на бэке. Это позволяет быстро поставлять софт и быть уверенным в том, что в будущем можно будет беспроблемно заменять плохие модули на более качественные аналоги. Прям как Корабль Тесея: на ходу меняем доски и плывем к цели.

![](/ru/overengineering/image_39720187421671190675164.jpg) Мы придерживаемся таких правил при разработке фронтовой части Wisey уже год. О том, какую архитектуру я разработал, описывал в [предыдущей статье](https://dou.ua/forums/topic/36547/). На данный момент мы имеем около 100 больших независимых модулей, каждый из которых выполняет определенную функцию. Многие из них были переписаны с нуля несколько раз, например модуль урока, аутентификации, оплат, личный кабинет пользователя и другие. В данном подходе хорошо то, что можно не менять старый код, если приходят новые требования, а просто написать новый модуль. Закрыть его feature flag и заменить старый, используемый в системе. Когда модуль протестирован, мы просто удаляем старую версию. Таким образом можно не беспокоиться о стабильности системы в продакшене. В крайнем случае есть возможность вернуть старую версию модуля на время исправлений. Также подобный подход упрощает A/B тестирование с помощью переключения версий модуля для разных пользователей. Кроме того, новому члену команды достаточно просто работать с большой кодовой базой: все модули очевидно придерживаются интерфейсов (контрактов). Я описал наш подход кратко и не повторял то, что уже написано умными людьми. Безусловно, тема очень глубокая и требует немало времени на изучение. Если она вам интересна, то советую ознакомиться:

- [CQRS (command-query responsibility segregation)](https://martinfowler.com/bliki/CQRS.html) + [ES (event sourcing)](https://martinfowler.com/eaaDev/EventSourcing.html) + [event-driven architecture](https://aws.amazon.com/event-driven-architecture/) - призваны декомпозировать систему на маленькие кусочки, которые можно легко собирать вместе;
- [Domain-driven design](https://grenka.ua/144685/predmetno-orientirovannoe-proektirovanie-ddd-strukturizatsiya-slozhnykh-programmnykh-sistem) - книга о том, как подружить бизнес и разработку ПО;
- [Методология языка Rust](https://doc.rust-lang.org/book/) - мне нравится взгляд авторов на проблемы языков программирования и методы их решения;
- [Scrum](https://www.bookovka.ua/ru/biznes-dengi-ekonomika/88241-scrum-revolyucionnyj-metod-upravleniya-proektami.html) - как правильно вести проекты и работать в команде.

## Вместо вывода

Приемлемое быстрое решение, которое решает проблему, лучше идеального, разработка которого займет месяцы. Время - очень ценный ресурс для бизнеса. Пока вы будете писать свой идеальный код, бизнес может закрыться. В этой статье я хотел обратить внимание на неутешительный тренд и призвать коллег глубже задумываться о потребностях клиентов и более сознательно подходить к своей работе. Я не призываю быть посредственностью. Код нужно писать хорошо, но важно прислушиваться к команде, уважать коллег и ставить цели бизнеса выше личных при работе над продуктом. Леонардо да Винчи пытался достичь совершенства в своей работе, поэтому часто не дописывал картины до конца. Представляете сколько шедевров потеряло человечество из-за критериев, придуманных в голове гения, но абсолютно нерелевантных для общей массы людей? Иногда совершенное - враг хорошего.
