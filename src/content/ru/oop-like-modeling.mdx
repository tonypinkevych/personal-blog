---
type: post
title: 'OOP modeling on front-end'
description: 'hi'
pubDate: 'Jul 08 2022'
published: false
---

import { PokemonsDeckOop } from '../../components/pokemons-deck-oop'

# OOP like modeling

Текущая проблема mobx – implicit data binding. Иногда сложно понять в чём заключается баг обновления состояния в компонентах.

Все классы имеют exposed data следовательно при моделировании ориентируешься больше на структуры данных, чем поведение объектов.

Плюсы текущего подхода:

- everything is explicit. Мы видим все объекты, которые используются и влияют на обновление UI компонентов;
- no hidden magic at all.
- shift from imperative programming to declarative.
- ментальный сдвиг от state management, data storage к models behaviour.
- вся эта реактивность с подписками из разных каналов классная до первого бага, при котором нужно будет отслеживать весь путь данных.

---

Задача: построить простейщий способ редактировать локальные текстовые файлы.

1. пользователь должен иметь возможность открыть файл;
2. отредактировать контент;
3. сохранить файл:
4. локально;
5. в память браузера;
6. отправить аналитику;

---

Самое важное в больших проектах — поддерживаемость кода. Для этого нужно писать как можно меньше кода. И, моё субъективное мнение, использовать меньше слоёв в приложении. Также для лучшей поддерживаемости кода нужно использовать независимые компоненты.
Но современные фреймворки и библиотеки ведут к обратному. Они превращают программистов в сборщиков. Нужна новая функция, окей, пойди поменяй вот эти 10 файлов и готово.
Я сам этим грешил, в этой статье можно (вставить ссылку на прошлую статью) найти пример того, как я сейчас считаю, делать не нужно.

Я предлагаю следующий подход к архитектуре фронтенд приложений. Далее все примеры будут на реакте.

Я предлагаю разбить работу на два независимых блока: ui и его состояния, и сущности, с которыми пользователь хочет взаимодействовать через интерфейс.
Сейчас речь пойдёт о последних и плавно перейдём к первым. Предлагаю мыслить о сущностях, с которыми мы взаимодействуем через интерфейс, как о шлюзах/окнах во внешний мир.

Например у нас есть

---

<PokemonsDeckOop client:idle />
