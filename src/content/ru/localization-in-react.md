---
type: post
title: 'Локализация веб-приложений по-человечески. Или почему мы разработали свой фреймворк'
description: 'Данная статья представляет новый метод локализации React-приложений, вдохновленный подходом Apple. Метод направлен на оптимизацию процесса разработки и повышение качества переводов путем изменения традиционного процесса i18n. В статье рассматриваются недостатки процессов i18n, описывается новый подход и его преимущества.'
pubDate: 'Sep 22 2024'
published: false
---

# Локализация веб-приложений по-человечески. Или почему мы разработали свой фреймворк

Аудитория: middle+ frontend developers

Формат: whitepaper

---

## Абстракция

Данная статья представляет новый метод локализации React-приложений, вдохновленный подходом Apple. Метод направлен на оптимизацию процесса разработки и повышение качества переводов путем изменения традиционного процесса i18n. В статье рассматриваются недостатки процессов i18n, описывается новый подход и его преимущества.

1. Введение
2. Проблемы традиционного подхода i18n
3. Новый метод локализации
4. Технические детали реализации
5. Сравнительный анализ
6. Заключение
7. Ссылки

## 1. Введение

Локализация является критическим аспектом разработки современных веб-приложений. Традиционные методы i18n, хотя и широко распространены, создают ряд проблем и неудобств как для разработчиков так и для переводчиков. Данная статья представляет инновационный подход к локализации React-приложений, который призван решить эти проблемы и оптимизировать процесс разработки и поддержки приложений с несколькими локализациями.

## 2. Проблемы традиционного подхода i18n

### 2.1. Предварительное создание файлов локализации

Стандартный подход i18n требует создания JSON-файлов с ключами локализации до начала разработки. Это включает:

1. создание JSON-файл с ключами локализации;
2. продумывание структуры и именование ключей заранее;
3. заполнение файла начальными значениями.

Только после этого можно приступать к использованию локализованных текстов в приложении.

### 2.2. Когнитивная нагрузка

Разработчики сталкиваются с дополнительной когнитивной нагрузкой:

1. необходимость переключения между файлами локализации и кодом в процессе работы;
2. запоминание и поиск корректных ключей. Сначала приходится идти в `.json` файл, смотреть какой ключ соответствует тексту и только после этого искать нужный компонент по ключу перевода;
3. поддержание синхронизации между кодом и файлом локализации. Особенно это влияет на продуктивность разработчиков в больших приложениях;
4. возникает риск опечаток и несоответствий между ключами в `.json` файле и в коде. Разработчикам приходится вручную перепроверять файлы.

### 2.3. Пример использования

```json
// JSON файл локализации (en.json)
{
  "greeting": "Hello",
  "welcome": "Welcome to our app",
  "user": {
    "profile": {
      "title": "Current User: {{name}}"
    }
  }
}
```

```tsx
// Использование в React-компоненте
function Welcome() {
  const { t } = useLocale()
  return (
    <div>
      <h1>{t('greeting')}</h1>
      <p>{t('welcome')}</p>
      <h2>{t('user.profile.title', { name: 'John' })}</h2>
    </div>
  )
}
```

## 3. Новый метод локализации

Наша гипотеза состояла в том, что если улучшить DX (developer experience) разработчиков и UX (user experience) переводчиков, то мы сможем реализовать первичную локализацию приложения и поддерживать её в будущем меньшими усилиями, чем при традиционном подходе.

### 3.1. Концепция

Наш подход, вдохновленный методологией Apple, меняет парадигму локализации React-приложений:

Разработчики пишут код так, как будто локализации не существует. Разработчик продолжает работать с кодом не касаясь сырых `json` файлов. А необходимые этапы перевода вынесены в отдельный автоматизированный процесс. Сгенерированные `json` файлы имеют читабельную структуру и комментарии, которые помогают с дебаггингом в редких случаях. Процесс локализации строится на файловой системе, чтобы использовать преимущества инструментов разработчика, такие как IDE и `git`.

### 3.2. Процесс работы

1. разработчики используют тексты в коде на основном языке (например, английском). Но оборачивают каждый текст в функцию `t`;
2. скрипт анализирует код и извлекает все строки для перевода в `json` файл;
3. на этапе сборки происходит оптимизация файлов для меньшей нагрузки на сеть пользователей.

## 4. Технические детали реализации

Пример использования:

```tsx
function Welcome() {
  const { t } = useLocale()
  return (
    <div>
      <h1>t`Hello`</h1>
      <p>t`Welcome to our app`</p>
      <h2>t`Current User: ${'John'}`</h2>
    </div>
  )
}
```

Вместо использования текстов напрямую, они становятся аргументами функции `t`.

#### 4.1. Генерация файла с локализацями

Скрипт

```bash
polyglotte extract-translations ./src --outfile=./localization.json --locales=en
```

автоматически извлекает строки для локализации из исходного кода. Его функционирование можно описать следующим образом:

1. **Анализ файловой структуры**: скрипт начинает работу с указанной директории (`./src`) и последовательно обрабатывает все файлы в ней и её поддиректориях;
2. **Идентификация локализуемых элементов**: в процессе анализа кода скрипт выявляет текстовые строки, подлежащие локализации (все аргументы функции `t`);
3. **Генерация результата**: по завершении анализа создается файл `localization.json`. Этот файл содержит структурированный список всех найденных строк для локализации.

Полученный JSON-файл служит основой и единственной точкой входа для дальнейшей работы над локализацией приложения.

```json
{
  "locales": ["en"],
  "keys": {
    "Hello": {
      "key": "Hello",
      "status": "new",
      "managed": "automatic",
      "comment": "Automatically generated from file=example/index.tsx, line=5, char=20",
      "en": "Hello"
    },
    "Welcome to our app": {
      "key": "Welcome to our app",
      "status": "new",
      "managed": "automatic",
      "comment": "Automatically generated from file=example/index.tsx, line=6, char=19",
      "en": "Welcome to our app"
    },
    "User Profile": {
      "key": "User Profile",
      "status": "new",
      "managed": "automatic",
      "comment": "Automatically generated from file=example/index.tsx, line=7, char=20",
      "en": "Current User: {{1}}"
    }
  }
}
```

Файл локализации может содержать дополнительную полезную информацию в виде метаданных:

1. **Скриншоты**: к каждой строке можно прикрепить ссылку на изображение экрана, где эта строка используется;
2. **Координаты текста**: можно указать, где именно на экране располагается каждая строка;
3. **Визуализация переводов**: используя скриншоты и координаты, можно наглядно показать контекст использования текста для вычитки профессиональным переводчиком.

```diff
{
    "locales": ["en"],
    "keys": {
        // ...
        "Welcome to our app": {
            "key": "Welcome to our app",
            "status": "new",
            "managed": "automatic",
            "comment": "Automatically generated from file=example/index.tsx, line=6, char=19",
            "en": "Welcome to our app",
+           "metadata": {
+               "screenshot": "./screenshots/welcome.jpg",
+   			"box": [
+   	            0.06133333333333333,
+   	            0.44584382871536526,
+   	            0.8746666666666667,
+   	            0.08060453400503778
+   			]
+           }
        }
    }
}
```

![Cover](/ru/localization-in-react/cover.webp)

#### 4.2. Генерация отдельных локализаций

После генерации основного файла локализации наступает этап автоматизированного перевода. Это необходимо, чтобы разработчик мог проверить вёртску на реальных ключах без ожидания финального перевода. Мы используем DeepL с кастомными словарями, он хорошо работает с markdown разметкой и позволяет сохранить консистентность между запросами.

Скрипт

```bash
polyglotte generate-locale ./localization.json --locales=en,es --provider=deepl --apiKey=*****
```

выполняет следующие действия:

1. **Анализ**: скрипт проводит сравнительный анализ файла локализации, выявляя ключи, которые уже имеют перевод, и те, которые еще не переведены;
2. **Перевод**: для непереведенных ключей скрипт обращается к DeepL API и добавляет нужные переводы прямо в файл. сгенерированные переводы маркируются для последующего рассмотрения профессиональными переводчиками.

```diff
{
-    "locales": ["en"],
+    "locales": ["en", "es"],
    "keys": {
        // ...
        "Hello": {
            "key": "Hello",
-            "status": "new",
+            "status": "needs_review",
            "managed": "automatic",
            "comment": "Automatically generated from file=example/index.tsx, line=5, char=20",
            "en": "Hello",
+           "es": "Hola"
        }
    }
}
```

#### 4.3. Разделение файла

Заключительным этапом процесса локализации перед релизом является подготовка оптимизированных переведённых файлов.

Скрипт

```bash
polyglotte prepare-translations ./localization.json
```

генерирует отдельные JSON-файлы для каждого языка. В перспективе планируется внедрение более гранулярного подхода с разделением переводов по отдельным страницам приложения.
Файл `en.json` намеренно генерируется пустым. Это обусловлено тем, что для базового языка ключи и их значения идентичны. Функция `t` имеет встроенный механизм обработки отсутствующих ключей. Если перевод для ключа не найден, функция возвращает исходную строку, заключенную в backticks.
Такой подход позволяет снизить размер финального файла и повысить отказоустойчивость в случае, когда какого-то ключе не существует.

Пример сгенерированных файлов:

```json
// en.json
{}
```

```json
// es.json
{
  "Hello": "Hola",
  "Welcome to our app": "Bienvenido a nuestra aplicación",
  "User Profile": "Cliente Activo: {{1}}"
}
```

#### 4.4. Реализация провайдера локализации

Для распространения данных локализации в React-приложении вместо singleton'а используется провайдер:

```tsx
// page.tsx
export default function Page() {
  // опознавание языка пользователя. Может происходить автоматически на основе данных браузера, или на основе данных в текущем pathname
  const userLanguage = useUserLanguage()
  return (
    // провайдер умеет находить и лениво загружать файлы локализаций
    <LocaleProvider language={userLanguage}>{/* ... */}</LocaleProvider>
  )
}
```

Это позволяет создать и использовать `Mock` провайдеры для автоматического тестирования и разработки компонентов, например в `storybook`.

#### 4.5. Нюансы (edge cases)

При внедрении системы локализации возникает ряд сценариев, требующих особого внимания.

**4.5.1. Работа с переменными**

Интерполяция переменных осуществляется стандартным способом:

```tsx
t`Hello, ${user.name}!`
```

В файле локализации это трансформируется в `Hello, {{1}}!`. Такой подход позволяет гибко адаптировать переводы, например: `¡Hola, {{1}}!`. DeepL почти без ошибок обрабатывает подобные конструкции, сохраняя плейсхолдеры.
Внутри файла с локализацией переменные маркируются индексами, поэтому количество возможных переменных неограниченно.

**4.5.2. Пользовательские ключи локализации**

Функция `t` поддерживает расширенный синтаксис с объектом настроек:

```tsx
t({
  key: 'username',
  comment: "This is user's name",
})`Hello, ${user.name}!`
```

Это отражается в файле локализации следующим образом:

```json
{
  // ...
  "keys": {
    "username": {
      "key": "username", // берётся из объекта
      "comment": "This is user's name", // берётся из объекта
      "en": "Hello, {{1}}"
      // ...
    }
  }
}
```

#### 4.5.3. Использование разных начертаний

Для расширенного форматирования текста в локализованных строках используется синтаксис Markdown. Это позволяет легко добавлять стилизацию без необходимости внедрения HTML-тегов непосредственно в строки перевода. Например `**Hello, ${user.name}!**`.

**4.5.4. Автоматизация в CI/CD**

Для минимизации человеческого фактора, процесс обновления локализаций интегрирован в CI:

```bash
polyglotte extract-translations ./src --outfile=./localization.json --locales=en && \
polyglotte generate-locale ./localization.json --locales=en,es --provider=deepl --apiKey=***** && \
polyglotte prepare-translations ./localization.json
```

Этот скрипт автоматически запускается при каждом PR, создавая коммит с обновленными ключами локализации.

**4.5.4. Обработка изменения ключей**

При изменении текста в коде:

```diff
function Welcome() {
    const { t } = useLocale();
    return (
        <div>
            <h1>t`Hello`</h1>
-            <p>t`Welcome to our app`</p>
+            <p>t`Welcome onboard`</p>
            <h2>t`User Profile`</h2>
        </div>
    );
}
```

И при повторном запуске скрипта, файл локализации автоматически обновляется:

```diff
{
    "locales": ["en", "es"],
    "keys": {
        // ...
        "Welcome to our app": {
            "key": "Welcome to our app",
-           "status": "new",
+           "status": "stale",
            "managed": "automatic",
            "comment": "Automatically generated from file=example/index.tsx, line=6, char=19",
            "en": "Welcome to our app",
            "es": "Bienvenido a nuestra aplicación"
        },
+       "Welcome onboard": {
+           "key": "Welcome onboard",
+           "status": "new",
+           "managed": "automatic",
+           "comment": "Automatically generated from file=example/index.tsx, line=6, char=19",
+           "en": "Welcome onboard"
+       },
    }
}
```

Далее разработчик должен вручную решить, что делать с подобными ключами: удалить их, или модифицировать. Благодаря `git diff` процесс становится очень удобным.

**4.5.5. Статусы ключей**

Система использует четыре статуса для ключей локализации:

1. `new` - новый ключ, созданный системой;
2. `stale` - неиспользуемый ключ, подлежащий удалению;
3. `needs_review` - автоматически переведенный ключ, требующий проверки;
4. `translated` - проверенный и готовый к использованию ключ.

Эти статусы помогают отслеживать жизненный цикл каждого элемента локализации и управлять процессом перевода.

#### 4.5.6. Типы менеджмента ключей

Существует 2 типа менеджмента ключей:

1. `automatic` - скрипт автоматически обновляет статусы и значения;
2. `manual` - программист, или переводчик вручную модифицирует данный ключ.

## 5. Сравнительный анализ

| Process        | i18n                                                | Polyglotte                                                  |
| -------------- | --------------------------------------------------- | ----------------------------------------------------------- |
| Data flow      | JSON → code                                         | Code / Figma → JSON                                         |
| Keys creation  | Manual                                              | Automatic                                                   |
| Keys usage     | Abstraction keys, for example: `user.profile.title` | Specific keys in plain english, for example: `User Profile` |
| Translation    | Manual                                              | Automatic                                                   |
| Variables      | Supported                                           | Supported                                                   |
| Pluralization  | Supported                                           | Not supported yet                                           |
| CI integration | Manual                                              | Automatic                                                   |

Проект был разработан для внутреннего использования нашей компанией, поэтому внешних тестов проведено не было. Но этот подход позволил нашей команде провести локализацию UI составляющей платформы всего за 3 дня. Мы вручную прошлись по кодовой базе, добавили ко всем строкам вызов `t`, после этого стало возможным автоматически использовать процесс переводов описанный выше. Поэтому, если оценивать субъективно, то можно считать, что проект оказался успешным.

За эти 3 дня мы перевели более 4-х тысяч ключей (если быть точным, то `4385`).

## 6. Заключение

Хоть текущая реализация не покрывает все возможные сценарии использования на данный момент, например нет поддержки `pluralization`, но она является хорошей базой для дальнейшего развития. Решение об изменении процесса создания JSON файла в автоматическом режиме сразу же решило множество проблем существующих раннее. Мы довольны результатом, подтвердили гипотезу и планируем дальше развивать этот фреймворк.

## 7. Ссылки

- [WWDC23: Discover String Catalogs | Apple](https://youtu.be/7xxUopPqjyI?si=dA-U1oTqbeo9zVce)
- [Localization by Apple](https://developer.apple.com/documentation/xcode/localization)
- [Template literals (Template strings)](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals)
